---
title: "RUV_Salmon_DESeq2_EdgeR_with_outliers"
author: "Raquel Pinho"
date: "1 de maio de 2019"
output: 
  html_document:
        toc: true
        toc_depth: 2
        toc_float: 
              collapsed: false
        number_sections: true
        fig.width: 11
        fig.height: 9
        fig.caption: true
        dev: png
        df_print: paged
        code_folding: hide
        self_contained: false
        keep_md: true
  word_document: default
editor_options: 
  chunk_output_type: inline
---

# Data

This code was writen using data from mhlz experiment 2016, where Malnourished and full fed animals were compared after the ingestion of regular milk, lysozyme-rich milk or no milk. The expression along the length of the intestinal tract were assessed by underlying distribution of RNA-seq data. In total we have seven groups and 4 or three animals per group.

I will first set the working directory to where output are going to be saved and choose the groups to be compared if it was not defined on the command line in the server, besides setting up the knitr options:

```{r setwd1, echo=TRUE}
#args = commandArgs(trailingOnly=TRUE)
setwd("C:/Users/rpmello/Desktop/Data Analysis RNASeq/Projeto_Salmon_DESeq_EdgeR")
#groups <- c(args[1],args[2])
#groups<-c("FFI","No_milkI")#colocar em ordem alfabética e com a inicial da seção
dir.create(file.path("C:/Users/rpmello/Desktop/Data Analysis RNASeq/Projeto_Salmon_DESeq_EdgeR/Output", sprintf("%s_vs_%s_Salmon_R_with_outliers",groups[1], groups[2])), showWarnings = FALSE)
output_dir<-file.path("C:/Users/rpmello/Desktop/Data Analysis RNASeq/Projeto_Salmon_DESeq_EdgeR/Output", sprintf("%s_vs_%s_Salmon_R_with_outliers",groups[1], groups[2]))
dir.create(file.path(output_dir, "Figures"), showWarnings = FALSE)
sprintf("Comparison of %s and %s.", groups[1], groups[2])
knitr::opts_chunk$set(echo = TRUE, results = "asis", include = TRUE, fig.path = file.path(output_dir,"Figures"), fig.width = 11, fig.height = 8, fig.show = "animated")
```

# DESeq2 analysis

I will follow the DESeq2 tutorial found [here](https://github.com/mikelove/asthma) and [here](Angus_workshop)

And I will start creating a table of counts with all the samples.But for this I will have to import the counts data and the metadata.

## Importing the data 

The data used was the quant.sf files output from the Salmon software. And I will select the data and the metadata to the groups selected for comparison.

```{r geting_counts, echo= TRUE, include= FALSE}
dataDir <- "C:/Users/rpmello/Desktop/Data Analysis RNASeq/Salmon/Salmon_comp_trim_quant.sf"
setwd("C:/Users/rpmello/Desktop/Data Analysis RNASeq/Projeto_Salmon_DESeq_EdgeR")
metadata <- read.csv("./Data/metadata_complete.csv")
selectMetadata <- metadata[which(metadata$Group_sectio %in% groups), ]
selectMetadata<- selectMetadata[order(selectMetadata$Group),]
files <- selectMetadata$list_of_files[which(selectMetadata$Group_sectio %in% groups)]
labels<- c(paste0(selectMetadata$Group, 1:(length(selectMetadata$Group)/2)))
group <- selectMetadata$Group
filessf<- gsub("quant[\\._]counts", "quant.sf", files)
filessf<-file.path(dataDir, filessf)
names(filessf) <-labels
tx2gene<- read.csv("./Data/tx2gene.txt", header = T)
head(tx2gene)  
colnames(tx2gene)<-c("TXNAME", "GENEID")
library('tximport')
txidata<- tximport(filessf, type = "salmon", tx2gene = tx2gene )
sprintf("SampleID %s and Label %s used for this comparison for  Pig %s", selectMetadata$SampleID, selectMetadata$Group_sectio, selectMetadata$Pig)
```

## Importing and creating the metadata table

```{r batch_factors1, echo= TRUE, include=FALSE}
cols<- c("Collection","RNA_ext", "Lib_const", "Lane","Litter")
selectMetadata[cols] <- lapply(selectMetadata[cols], factor)
Weight<-selectMetadata$Weight_3Week
selectMetadata$Labels<- labels
row.names(selectMetadata)<-selectMetadata$Labels
selectMetadata$Time<-gsub("K","k",selectMetadata$Time)
```

The metadata for the specified comparison was:

```{r metadata}
head(selectMetadata)
```

### Removing dependent variables

I will remove the metadata that does not present a variation in this comparison or have all unique values in this comparison

```{r rm_factor}
batch_effects<-sapply(1:ncol(selectMetadata), function(i){length(unique(selectMetadata[,i]))!= 1 & length(unique(selectMetadata[,i])) != length(selectMetadata[,i])})
batch_effects<-selectMetadata[,batch_effects]
dependent<-sapply(1:ncol(batch_effects), function(i){length(unique(batch_effects[1:4,i])) == 1 & length(unique(batch_effects[5:8,i])) == 1})
independent<-which(!dependent)
batch_effects<-batch_effects[,independent]
batch_effects$Group<-group
batch_effects
```

From now on I will use the manual from [RUVSeq](https://bioconductor.org/packages/release/bioc/vignettes/RUVSeq/inst/doc/RUVSeq.pdf) and the manual from [DESeq2](https://www.bioconductor.org/packages/devel/workflows/vignettes/rnaseqGene/inst/doc/rnaseqGene.html#using-ruv-with-deseq2)

## DESeq object

Creating a DESeqDataSet for the in this case we will use the design ~Group, because, for know we are only interested in the normalized counts to filter low counts and calculate the variation varible with RUV.  


```{r DESeq_norm}
library(DESeq2)
dds <-DESeqDataSetFromTximport(txidata, batch_effects, as.formula("~Group"))
#It doesn't matter the formula now, because I am just interested in the counts, but I 
dds<-estimateSizeFactors(dds)
dds<-DESeq(dds)
```

### Filtering low expressed genes

I wil remove the genes if low counts, and I am being very stringent here, removing the ones tha have lower than 20 counts in all the samples and the ones that have less then 5 counts in at least two samples. 

I will use the [EDASeq](http://bioconductor.org/packages/release/bioc/manuals/EDASeq/man/EDASeq.pdf) package just to create an object were I can store the data and the metadata for multiple analysis.

```{r EDAseq}
library(EDASeq)
library(RColorBrewer)
#creating a set with the expression dat
set<-newSeqExpressionSet(DESeq2::counts(dds), phenoData= batch_effects)
set
colors<-brewer.pal(4,"Set2")
idx  <- rowSums(EDASeq::counts(set) > 5) >= 2
set  <- set[idx, ]
filter<-apply(EDASeq::counts(set),1,function(x){length(x[x>5])>2})
set <-set[filter,]
sprintf("Removed %s genes with low counts from %s total genes", nrow(EDASeq::counts(dds))-nrow(EDASeq::counts(set)),nrow(DESeq2::counts(dds)))
```

## RUVSeq

The number of sig DE genes with mod1 (~Group) was:

```{r mod1}
res<-results(dds)
sigres<-res[!is.na(res$padj),]
sigres<-sigres[sigres$padj<0.1 & sigres$log2FoldChange>1| sigres$log2FoldChange< -1,]
dim(sigres)
```

### Box plot of the counts per sample 

We can analyze the variation of the counts before normalization and reduced variation.

```{r box_plot_counts}
plotRLE(set, outline =F, ylim=c(-2,2), col=colors[set$Group])
plotPCA(set, col=colors[set$Group])
```
 
### Upper quartile normalization

The upper quartile normalization [(UQ)](https://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-11-94) normalizes the data  accounting for the most highly expressed transcripts, since there is a bias on the number of reads  associated to them, i.e, more expresssed trancripts generate more reads and futhermore the number of reads on these highly expressed genes is proportional to the total number of reads in the sample (if samples are in individual lanes or in the same lane), which is not the case for me. [Here](http://vinaykmittal.blogspot.com/2013/10/fpkmrpkm-normalization-caveat-and-upper.html)a more human explanation. And [here](https://academic.oup.com/bib/article/14/6/671/189645) a more recent paper on RNA data normalization. 

```{r upper}
set_n<-betweenLaneNormalization(set,which = "upper")
set_n$Group<-factor(set_n$Group)
plotRLE(set_n, outline=F, col=colors[set_n$Group])
plotPCA(set_n,col=colors[set_n$Group])
```

### Using empirical control genes 

Since no spike in were used we will use the genes that have least changed between samples ( least significantly DE genes ) and use them as controls for the unwanted factors. So first we do a DE analysis and find the genes and then we do the normalization. 

### Empirical controls using the prior DE analisis using DESeq2 

Now we are going to use the DESeq2 to do DE analysis so we can pick the least DE genes as controls.In this case I will estimate only one unwanted variacen variable. 

```{r prior_DESEq}
#Using RUVSeq
library(RUVSeq)
not.sig <- rownames(res)[which(res$pvalue > .2)]
empirical <- rownames(set_n)[ rownames(set_n) %in% not.sig ]
if("RDAVIDWebService" %in% (.packages())){
  detach("package:RDAVIDWebService", unload=TRUE) 
}
set_n <- RUVg(set_n, empirical, k=1)
pData(set_n)
```

Using the unwanted variance variable in DESeq ( ~ W1 + Group).

```{r ruv_var}
ddsruv <- dds
ddsruv$W1 <- set_n$W_1
design(ddsruv) <- ~ W1 + Group
dds<-ddsruv
```

## Check sample distances

We will use the `dist` function to calculate Euclidean distances bewteen samples and see with the sample within groups are similar. And in this case we will use the rlog transformed data so the high variance if the low expressed genes do not influence the calculations.

Poisson distance of the smples and euclidean of rlog transformed data.

```{r poisson_dist_rlog, include= FALSE, echo= TRUE}
# to see it as a Poisson distances
library("PoiClaClu")
library(gplots)
library(RColorBrewer)
library(pheatmap)
rlogdds<- rlog(dds)
saveRDS(rlogdds,file = file.path(output_dir,sprintf("%s_vs_%s_rlog_counts_Sal_with_outliers.RDS",groups[1], groups[2])))
poisd<-PoissonDistance(t(DESeq2::counts(dds)))
samplePoisDistMatrix<-as.matrix(poisd$dd)
row.names(samplePoisDistMatrix)<-paste(rlogdds$RNA_ext, rlogdds$Group, sep="_")
## sample dist
sampleDist<-dist(t(assay(rlogdds)))
sampleDistMatrix <- as.matrix(sampleDist)
rownames(sampleDistMatrix) <- paste(rlogdds$RNA_ext, rlogdds$Group, sep="-")
colnames(sampleDistMatrix) <- NULL
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255)
pheatmap(sampleDistMatrix,
         clustering_distance_rows=sampleDist,
         clustering_distance_cols=sampleDist,
         col=colors)
```

The heatmap of the rlog transformed counts using poisson distance.

```{r heatmap_rlog_poisson}
colors<- colorRampPalette(rev(brewer.pal(9,"Blues")))(255)
hc<- hclust(poisd$dd)
heatmap.2(samplePoisDistMatrix, Rowv=as.dendrogram(hc), symm=T, trace="none", col= colors, margins=c(2,10), labCol=F)
```

We can also see the PCA plot:

```{r PCA_plot}
library(ggplot2)
z <-plotPCA(rlogdds, intgroup = c( "Group"))
z+ geom_text(aes(label = selectMetadata$Pig))
# Using the both
percentVar <- round(100 * attr(z, "percentVar"))
ggplot(as.data.frame(z$data), aes(PC1, PC2, shape=Group, color=rlogdds$Collection)) +  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) + 
  coord_fixed()+ geom_text(aes(label = selectMetadata$Pig))
```

## Differrential expression analaysis

It is convenient to make sure that FF is the first level in the Diet factor so the default log2 fold change can be calculatedmalnourished over full fed.

Now, we can run the DESeq function that will estimate the size factors (estimate for differences due to library size), estimate dispersion for each gene, and fit in a generalized linear model.


we have this number of genes with padj < 0.1 L2FC 1. the L2FC estimation is based on MLE (betaprior is False) and the last variable is the contrast that is used.  

```{r DE_test, include= FALSE, echo= TRUE}
#First, we will exclude the transcripts with 0 reads and the transcripts with very low expression
dds <- dds[rowSums(DESeq2::counts(dds)) > 3,]
keep <- rowSums(DESeq2::counts(dds) >= 10) >= 3
table(keep)
dds <- dds[keep,] # filter them out
# Now, we can call the DESeq function
dds <- DESeq(dds, betaPrior = FALSE)
resultsNames(dds)
res<- results(dds)
#in this defaut, the L2FC estimation is based on MLE (betaprior is False) and the last variable is the contrast that is used. 
```

The summary of the results  from the DE analysis using DESeq2, where the low counts were excluded from testing due to being lower than the mean count.

```{r summary_of_results, echo= TRUE}
summary(res)
#the low counts in the summary is the number of genes that were excluded from testing because the countes were lower than the mean count calculated by DESeq.
# it will test the last variable from the design , 
# This will give me the genes that are significantly different with a adj. pvalue < 0.1.
# To make it more stringent we can use adj.pvalue < 0.05, and L2fc > 2, or < -2.
```

Now we can filter the results by p. adjusted and log2foldChange values.Here we used padj< 0.1, log2FoldChange < -1 or log2FoldChange > 1. The table and the dimentions of the table of DE genes were: 

```{r DE_results_table}
res.sort<- res[order(res$pvalue), ]
#head(res)
#Considering a padj < 0.1 being significant  we can subset the significant differentiated genes
#resSig_Salmon <- subset(res, padj< 0.1)
res<-as.data.frame(res)
resSig_Salmon <- res[res$padj< 0.1,]
resSig_Salmon <- subset(resSig_Salmon, log2FoldChange < -1 | log2FoldChange > 1)
saveRDS(resSig_Salmon, file = file.path(output_dir,sprintf("%s_vs_%s_Salmon_resSig_w_outlier.RDS",groups[1], groups[2])))
head(as.data.frame(resSig_Salmon))
dim(resSig_Salmon)
```

### Increased strigency 
Being more stringent we can see the number of genes 
with padj< 0.1 and L2FC < -1.5 or > 1.5

```{r stringent_call}
resSig_Salmon<-resSig_Salmon[order(resSig_Salmon$padj), ]
resSig_Salmon1.5 <- subset(resSig_Salmon, log2FoldChange < -1.5 | log2FoldChange > 1.5)
dim(resSig_Salmon1.5)
```

### Sorting by up regulated or down regulated genes 

First a look at the top downregulated genes (based on log2foldchange):

```{r downregulated_genes_table}
# sorting by the Log2FoldChange
head(as.data.frame(resSig_Salmon[order(resSig_Salmon$log2FoldChange), ])) # stronger downregulation

topdown_salmon<-rownames(head(resSig_Salmon[order(resSig_Salmon$log2FoldChange), ],10)) # stronger downregulation

#Getting the down regulated genes 
downresSig_Salmon<-resSig_Salmon[resSig_Salmon$log2FoldChange < -1,]
downresSig_Salmon<-downresSig_Salmon[order(downresSig_Salmon$log2FoldChange),]
dim(downresSig_Salmon)
```

And now at the upregulated genes:

```{r upregulated_genes_table}

head(as.data.frame(resSig_Salmon[order(-resSig_Salmon$log2FoldChange), ])) #stronger upregulation

topup_salmon<-rownames(head(resSig_Salmon[order(-resSig_Salmon$log2FoldChange), ],10)) #stronger upregulation

#Getting the up regulated genes
upresSig_Salmon<-resSig_Salmon[resSig_Salmon$log2FoldChange > 1,]
upresSig_Salmon<-upresSig_Salmon[order(-upresSig_Salmon$log2FoldChange),]
dim(upresSig_Salmon)

```


#### List of genes with padj < 0.1, L2FC < -1 or > 1.

Now we can have the list of the genes that are DE expressed and down or up regulated and then convert the ensembl ids into gene names using BiomaRt.  

The number of downregulated genes with successful convertion and the top 30 downregulated (based on log2folfchange) genes were:

```{r list of down_genes_list}
library(biomaRt)
mart<- useMart("ensembl")
Pig_ensembl<- useDataset("sscrofa_gene_ensembl", mart=mart)
Human<-useDataset("hsapiens_gene_ensembl", mart=mart)
down_genes_names<- getBM(attributes = c("ensembl_gene_id","external_gene_name"), filters= "ensembl_gene_id", values = rownames(downresSig_Salmon), mart = Pig_ensembl)
down_genes_names<-transform(merge(as.data.frame(downresSig_Salmon),down_genes_names,by.x=0, by.y ="ensembl_gene_id",all=TRUE), row.names=Row.names, Row.names=NULL)
down_genes_names_Salmon<- down_genes_names[order(down_genes_names$log2FoldChange),]
#The number of genes  we were able to find the gene name on BiomaRt
sum(down_genes_names_Salmon$external_gene_name != "")
head(down_genes_names_Salmon[order(down_genes_names_Salmon$padj),], 30)
```

For the upregulated: 

```{r up_gene_list}
up_genes_names<- getBM(attributes = c("ensembl_gene_id","external_gene_name"), filters= "ensembl_gene_id", values = rownames(upresSig_Salmon), mart = Pig_ensembl)
up_genes_names<-transform(merge(as.data.frame(upresSig_Salmon),up_genes_names,by.x=0, by.y ="ensembl_gene_id",all=TRUE), row.names=Row.names, Row.names=NULL)
up_genes_names_Salmon<- up_genes_names[order(up_genes_names$log2FoldChange),]
sum(up_genes_names_Salmon$external_gene_name != "")
#The number of genes  we were able to find the gene name on BiomaRt
head(up_genes_names_Salmon[order(up_genes_names_Salmon$padj),],30)
```


I will use the list to annotate the total DE genes using the Biomart in Ensembl.And get the top 6 with lowest padjusted.

```{r list_of_DE_genes}
#I will get the IDS and will use the following code
gene_names<- getBM(attributes = c("ensembl_gene_id","external_gene_name"), filters= "ensembl_gene_id", values = rownames(resSig_Salmon), mart = Pig_ensembl)
gene_names<-transform(merge(as.data.frame(resSig_Salmon),gene_names,by.x=0, by.y ="ensembl_gene_id",all=TRUE), row.names=Row.names, Row.names=NULL)
gene_names<-as.data.frame(gene_names[order(gene_names$padj),])
head(gene_names)
``` 

## Diagnostic plots

To plot the counts of specific genes we can use the name of the gene or a a specific value related to it.

### Volcano plot 

```{r Volcano_plot}
# volcano plot 
plot(res$log2FoldChange, -log(res$pvalue),main ="Volcano plot Salmon data from DESeq2", xlab= "Log2FoldChange", ylab = "-log(Pvalue)", pch = 21, col=ifelse(res$pvalue <0.001,"red","black"), xlim= c(-5,5), ylim =c(0,25), abline(v=c(-2,2)))
```

### Plotting the gene with lowest p. adjusted

```{r lowest_padj}
# using the lower padj
topGene<- row.names(resSig_Salmon[which.min(resSig_Salmon$padj),])
plotCounts(dds,gene= topGene,main = gene_names$external_gene_name[1], intgroup="Group")
```

### to do the MA plot:

```{r MA_plot}
plotMA(res, ylim=c(-20,20))
```

### To plot dispersion.(within group variability of each gene )

```{r dispersion_plot}
plotDispEsts(dds)
```

### histogram of pvalues

```{r pvalues_histogram}
hist(res$pvalue[res$baseMean>1], breaks=20, col="grey50", border="white")
```

### Clustering
Clustering the rlog counts of the 50 more variable DE genes

```{r Clustering_rlog}
library(genefilter)
#most hihgly variable genes
topVarGenes<- head(order(-rowVars(assay(rlogdds))),50)
colors<- colorRampPalette(rev(brewer.pal(9,"PuOr")))(255)
sidecols<- c("grey", "dodgerblue")[rlogdds$Group]
mat<- assay(rlogdds)[topVarGenes,]
mat<- mat - rowMeans(mat)
colnames(mat)<- paste0(rlogdds$Group)
heatmap.2(mat,Colv=F, trace="none", col=colors, ColSideColors=sidecols, labRow=F, mar=c(10,2),scale="row")
```


### Doing the clustering with normalized counts instead of rlog Counts

TPM of the 150 more variable DE genes(if DE genes < 150, all genes)

```{r import_TPM, include=FALSE}
#create an object with the tpm file names

tpmDE<- DESeq2::counts(dds[row.names(dds) %in%  row.names(resSig_Salmon),], normalized =T)
tpmDE<-tpmDE[rowSums(tpmDE)>15,]
dim(tpmDE)

var_genes <- apply(tpmDE, 1, var)
head(var_genes)

# Get the gene names for the top 100 most variable genes
len<-ifelse(nrow(tpmDE)> 150, 150,nrow(tpmDE))
select_var <- names(sort(var_genes, decreasing=TRUE))[1:len]#DE genes with L2FC 1

head(select_var)
# Subset the normalized counts dataframe, grabbing the select_var genes
highly_variable_norm_counts <- tpmDE[select_var,]

# check the dimensions and the first few rows
dim(highly_variable_norm_counts)
head(highly_variable_norm_counts)
```

```{r tpm_clustering}
# Prepare for the heatmap

# Get some nicer colours
mypalette <- brewer.pal(11,"RdYlBu")

morecols <- colorRampPalette(mypalette)

# Load library for heatmap
heatmap.2(highly_variable_norm_counts, col=rev(morecols(50)), trace="none",
              main="Most variable genes across samples", scale="row",
              labCol = labels)

#To save the gene lists in both the cluster( 100 more variable genes in the resSig_Salmon2 table) and in the resSig_Salmon2 so I can used the transcripts to annotation and the other downstream application like panther or DAVID.
```

Cluster with all the DE genes using TPM


```{r cluster_tpmde_all1}
DE_counts<- tpmDE
heatmap.2(DE_counts, col=rev(morecols(50)), trace="none",
              main="Most variable genes across samples", scale="row",
              labCol = labels)
```

# Pathway analysis using DAVID and Reactome


I will use the lists to do the Pathway analysis with ReactomePA and DAVIDWebService

Fist, geting the GO terms for the DEgenes (padj,0.1, L2FC 1)- this will show only in R. And for that I will connect to DAVID. 

```{r DAVID_WEB, include= FALSE, echo=TRUE}
#connecting to the DAVID in the R 
library(RDAVIDWebService)
david<- DAVIDWebService$new(email="rdpinho@ucdavis.edu", url="https://david.ncifcrf.gov/webservice/services/DAVIDWebService.DAVIDWebServiceHttpSoap12Endpoint/")
david$getStub()
connect(david)
is.connected(david)
#And now I will use the gene table from the EdgeR to gete the reports from DAVID 
DAVID_results_DESeq<- addList(david, row.names(resSig_Salmon), idType = "ENSEMBL_GENE_ID" , listName = sprintf("%s_v_%s_Sig_genes_DESeq2", groups[1],groups[2]) ,listType = "Gene" )
#And to see if the genes were the right background
david
```
To see the percentage of the genes that were identified by the DAVID

```{r DAVID_percentage}
DAVID_results_DESeq$inDavid
```

And then you can create the results charts from DAVID and filter it by biological process:

```{r DAVID_data_from_R}
DAVID_results_chart<- getFunctionalAnnotationChart(david)
#If I want to create a file with the chart information I would use the following code:
#DAVID_results_chart<-DAVIDFunctionalAnnotationChartFile(DAVID_results_chart)
DAVID_results_chart_DESeq_BP<-DAVID_results_chart[DAVID_results_chart$Category == "GOTERM_BP_DIRECT" & DAVID_results_chart$PValue < 0.05,]
```

Plot of the top pathways and the evidence found in the list of DE genes.

```{r plot2D_BP}
if(dim(DAVID_results_chart_DESeq_BP)[1]>0){
plot2D(DAVIDFunctionalAnnotationChart(DAVID_results_chart_DESeq_BP[1:5,]),
       color=c("FALSE"="black", "TRUE"="green"))
# We can see the top 5 GO pathways for biological process, and note how the evidence is true in our data for each of the genes in the pathway( if it is present on our sample or not)
#We can also use the chart to do a godag plot
} else {
  print("No significant term found")
}
DAVIDGODag_DESeq<-DAVIDGODag(DAVIDFunctionalAnnotationChart(DAVID_results_chart_DESeq_BP), type ="BP",pvalueCutoff=.001)
#I can isolate the significant ones by doing a dataframe but the resulting plot is the same 
#sig_DAVID_RES_CHART<- DAVID_results_chart_BP[DAVID_results_chart_BP$PValue <0.001,]
#sig_DAVID_RES_GODAG<- DAVIDGODag(DAVIDFunctionalAnnotationChart(sig_DAVID_RES_CHART), type ="BP",pvalueCutoff=.001)
#we used a cutoff of 0.001 f or the pvalue. And now we can inspect the Dag object
```

The Pathways with pvalue lower than 0.0001 and table containing the pathways and pvalues.

```{r BP_sig_0001}
sigCategories(DAVIDGODag_DESeq, p=0.0001)
summary(DAVIDGODag_DESeq)
show(DAVIDGODag_DESeq)
# we can see by the FDR column that only the first 3 pathway are significant
```

GoDag term graph 

```{r pathway_graph, include=FALSE, echo=TRUE}
library(Rgraphviz)
plotGOTermGraph(g=goDag(DAVIDGODag_DESeq), r= DAVIDGODag_DESeq, max.nchar= 20, node.shape="ellipse",node.colors=c(sig="red", not="white"))

head(DAVID_results_chart_DESeq_BP)
```

## Using GOplot to visualize the GOterm from DAVID


First, we have to put the data in the format required by the package.

```{r checking the data, include= FALSE}
#for the expression data I will use the counts from the DGElist from the importated salmon data.
cts<-DESeq2::counts(dds, normalized=TRUE)
saveRDS(cts,file = file.path(output_dir,sprintf("%s_vs_%s_counts_TPM_Sal_with_outliers.RDS",groups[1], groups[2])))
eset <- cts
genelist<- as.data.frame(resSig_Salmon)
names(genelist)[2]<-"logFC"
genelist$ID<-as.factor(rownames(genelist))
genelist<-genelist[,c(7,2,6)]
david_fun<- DAVID_results_chart_DESeq_BP
Term<- gsub("^.*?~","",DAVID_results_chart_DESeq_BP$Term)
ID<- gsub("~.*", "", DAVID_results_chart_DESeq_BP$Term)
#removing the GOID of the term. the(^) is the beginig of the string, (.) matching any characther, (*)repeated multiple times until get to ~, and plepace it by nothing "".The ? makes it to match until the first ~ , if there were two ~. 
david_fun$Term<-as.factor(Term)
david_fun$ID<- as.factor(ID)
david_fun$Category <-as.factor(c(rep("BP", length(david_fun$Category) )))
if(dim(david_fun)[1]>0){
colnames(david_fun)[13]<-"adj_pval"
david_fun <- david_fun[,c(1,14,2,6,13)]
head(david_fun)
#Now I will choose the first 5 more significant processes
process<-as.character(david_fun[order(david_fun$adj_pval),3])[1:5]
dataGOplot<-list(eset = eset,genelist = genelist,david = as.data.frame(david_fun),process = process)
}else{
  print("Functional chart empty")
}

```

Now, that we have the data let's try to plot it using GOplot.

```{r GOplot_circ, include=FALSE}
library(GOplot)
if(dim(david_fun)[1]>0){
circ<- circle_dat(dataGOplot$david,dataGOplot$genelist)
}
```

### Plot the pathway colered by z-score significance
```{r GoBar}
if(dim(david_fun)[1]>0){
print(GOBar(circ, order.by.zscore = T ))}else {
  print("No significant terms")
}
```

###Bubble plot of pathways
```{r GOBubble}
if(min(circ$adj_pval)<0.05){
print(GOBubble(circ, labels = 1))} else {
  print("No significant terms")
}
```

### Plot significant enriched pathways and DE Genes

This plot is interesting because it shows which genes are up and down on the pathway
```{r GOCircle}
if(dim(david_fun)[1]>0){
nsub<- ifelse(dim(circ[!duplicated(circ$term), ])[1] > 10, 10, dim(circ[!duplicated(circ$term), ])[1]); 
print(GOCircle(circ,nsub = nsub))} else {
  print("No significant terms")
}
```

I can also plot the relationship between the DE genes and the most enriched pathways

```{r GOplot_terms_and_genes}
if(dim(david_fun)[1]>0){
subData <- subset(circ, term %in% process);
genes<-subset(genelist, ID %in% subData$genes);
All_genes<- getBM(attributes = c("ensembl_gene_id","external_gene_name"), filters= "ensembl_gene_id", values = row.names(res), mart = Pig_ensembl);
All_genes$external_gene_name<-ifelse(All_genes$external_gene_name=="", All_genes$ensembl_gene_id, All_genes$external_gene_name)
names_subData<- subset(All_genes, ensembl_gene_id %in% subData$genes);
names_subData$external_gene_name<- ifelse(names_subData$external_gene_name == "", names_subData$ensembl_gene_id, names_subData$external_gene_name);
chord <- chord_dat(circ, genes = genes, process = dataGOplot$process);
chord_names<-as.data.frame(cbind(chord, names_subData[,"external_gene_name"][match(rownames(chord), names_subData$ensembl_gene_id)]));
row.names(chord)<-chord_names$V7;
chord<-chord[,colSums(chord != 0) > 0];
print(GOChord(chord));
terms<-dataGOplot$process[!is.na(dataGOplot$process)]
if(length(terms)>2){
print(GOCluster(circ, terms, clust.by = "term", lfc.col = c('darkgoldenrod1','black','cyan1')))}} else {
  print("No significant term found!")
}
#the GOCluster indicated in the outer ring the pathway that the gene is associated to, the inner ring shows the log2fc of the gene and the clustering the gene by category, euclidean average 
```

## Using Biomart to convert the genes names into entrez ID (human) so I can use ReactomePA to do the pathway analysis

First table converting all the genes to entrex id and then filtering by padj < 0.1
 
```{r entrez_id_all, include=FALSE, echo=TRUE}
allentrez<- getBM(attributes = c("external_gene_name", "entrezgene"), filters= "external_gene_name", values = All_genes$external_gene_name, mart = Human) 
# Removing duplicates on allentrez
dup<-which(duplicated(allentrez$external_gene_name))
ind<-sapply(dup,function(x){ 
    ind<-c();
    z<- allentrez$external_gene_name[x];
    z<- allentrez[ allentrez$external_gene_name == z, ];
    ind<-c(ind, row.names(z[which.max(z$entrezgene),]))
})
allentrez<-allentrez[-as.numeric(ind),]
##Adding logfoldChange information
l2fc<- as.data.frame(res[,c(2,6)])
All_genes_entrez_rank<-merge(l2fc, All_genes, by.x = "row.names",by.y = "ensembl_gene_id")
###add entrez
All_genes_entrez_rank<- merge(All_genes_entrez_rank, allentrez, by= "external_gene_name")
#removing duplicates
dup<-which(duplicated(All_genes_entrez_rank$external_gene_name))
length(dup)
names_d<-sapply(dup,function(x){ 
            names_d<-c();
            n<-paste0(All_genes_entrez_rank$external_gene_name[x],"_1");
            names_d<-c(names_d,n)})
for(i in 1:length(dup)){
  All_genes_entrez_rank$external_gene_name[dup[i]]<-names_d[i]
}
saveRDS(All_genes_entrez_rank, file = file.path(output_dir,sprintf("%s_vs_%s_All_entrez_rank_Sal_w_outliers.RDS",groups[1], groups[2])))
all_genes_list<-All_genes_entrez_rank$log2FoldChange
names(all_genes_list)<-All_genes_entrez_rank$entrezgene
all_genes_list<-sort(all_genes_list, decreasing = T)
DE_genes_entrez_rank<- All_genes_entrez_rank[All_genes_entrez_rank$padj < 0.1 & !is.na(All_genes_entrez_rank$padj),]
DE_genes_list<- DE_genes_entrez_rank$log2FoldChange
names(DE_genes_list)<- DE_genes_entrez_rank$entrezgene
DE_genes_list<- sort(DE_genes_list, decreasing = T)
```

## Using reactome to analize subsetted from all genes

```{r Reactomeall, echo=TRUE, include=FALSE}
library(ReactomePA)
x<- enrichPathway(gene = DE_genes_entrez_rank$entrezgene,readable = T, qvalueCutoff = 0.1)
```

```{r Reactome_plots}
if(!is.null(x)){
if(min(x@result$p.adjust)<0.05){
sprintf("Barplot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s", groups[1],groups[2]);
print(barplot(x, showCategory = 30));
sprintf("Dotplot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s", groups[1],groups[2]);
print(dotplot(x, showCategory=15));
sprintf("Enrichment map plot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s", groups[1],groups[2]);
print(emapplot(x, showCategory = 15, color = "p.adjust",layout = "kk",colorEdge = TRUE)); 
print(cnetplot(x,showCategory = 5, categorySize = "pvalue", foldChange = DE_genes_entrez_rank$log2FoldChange, node_label= F, colorEdge = T))}} else {
  print("no enriched term found")
}
y<- gsePathway(DE_genes_list, nPerm = 1000,minGSSize = 10, pvalueCutoff = 0.05, pAdjustMethod = "BH")
if(nrow(y) > 0){
print(gseaplot(y, geneSetID =(as.data.frame(y))[1,1],title = as.character((as.data.frame(y))[1,2])));
print(cnetplot(y, categorySize = "pvalue", foldChange = DE_genes_entrez_rank$log2FoldChange,colorEdge = T));
print(emapplot(y, showCategory = 15, color = "p.adjust",layout = "kk"));
}
#DEunique<- DE_genes_list[!duplicated(names(DE_genes_list))]
```

## Reactome of the upregulated genes

```{r Reactomeup, echo=TRUE, include=FALSE}
upentrez<- All_genes_entrez_rank[All_genes_entrez_rank$Row.names %in% row.names(upresSig_Salmon),] 
up_genes_list<-upentrez$log2FoldChange
names(up_genes_list)<-upentrez$entrezgene
up_genes_list<-sort(up_genes_list, decreasing = T)
x<- enrichPathway(gene = upentrez$entrezgene,readable = T)
```

```{r reactome_plots_up}
if(!is.null(x)){
if(min(x@result$p.adjust)<0.05){
sprintf("Barplot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s up regulated genes", groups[1],groups[2]);
print(barplot(x, showCategory = 30));
sprintf("Dotplot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s up regulated genes", groups[1],groups[2]);
print(dotplot(x, showCategory=15));
sprintf("Enrichment map plot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s upregulated genes", groups[1],groups[2]);
print(emapplot(x, showCategory = 15, color = "p.adjust",layout = "kk",colorEdge = TRUE));
print(cnetplot(x,showCategory = 5, categorySize = "pvalue", foldChange = up_genes_list, node_label= F, colorEdge = T));
}}
y<- gsePathway(up_genes_list, nPerm = 1000,minGSSize = 10, pvalueCutoff = 0.05, pAdjustMethod = "BH")
if(nrow(y) > 0){
print(gseaplot(y, geneSetID =(as.data.frame(y))[1,1],title = as.character((as.data.frame(y))[1,2])));
print(cnetplot(y, categorySize = "pvalue", foldChange = upentrez$log2FoldChange,colorEdge = T));
print(emapplot(y, showCategory = 15, color = "p.adjust",layout = "kk"));
}
```

## Reactome of downregulated genes

```{r Reactomedown, echo=TRUE, include=FALSE}
downentrez<- All_genes_entrez_rank[All_genes_entrez_rank$Row.names %in% row.names(downresSig_Salmon),]
downentrez<-downentrez[order(downentrez$log2FoldChange, decreasing = T),]
down_genes_list<-downentrez$log2FoldChange
names(down_genes_list)<-downentrez$entrezgene
x<- enrichPathway(gene = downentrez$entrezgene, readable = T)
```

```{r reactomrdown_plots}
if(!is.null(x)){
if(min(x@result$p.adjust)<0.05){
sprintf("Barplot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s downregulated genes", groups[1],groups[2]);
print(barplot(x, showCategory = 30));
sprintf("Dotplot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s downregulated genes", groups[1],groups[2]);
print(dotplot(x, showCategory = 15));
sprintf("Enrichment map plot for the most enriched reactome pathway for Salmon/DESeq analysis for comparison %s vc %s downregulated genes", groups[1],groups[2])
print(emapplot(x, showCategory = 15, color = "p.adjust",layout = "kk")); 
print(cnetplot(x,showCategory = 5, categorySize = "pvalue", foldChange = down_genes_list, node_label= FALSE, colorEdge = TRUE));
}}
y<- gsePathway(down_genes_list, nPerm = 1000,minGSSize = 10, pvalueCutoff = 0.05, pAdjustMethod = "BH")
if(nrow(y) > 0){
print(gseaplot(y, geneSetID =(as.data.frame(y))[1,1],title = as.character((as.data.frame(y))[1,2])));
print(cnetplot(y, categorySize = "pvalue", foldChange = downentrez$log2FoldChange,colorEdge = T));
print(emapplot(y, showCategory = 15, color = "p.adjust",layout = "kk"))
}
#downunique<- down_genes_list[!duplicated(names(down_genes_list))]
#viewPathway(as.character((as.data.frame(y))[1,2]), readable = T, foldChange = downunique )
``` 


# EdgeR analysis

We can repeat the same analysis using edgeR as the inference engine (Robinson, McCarthy, and Smyth 2009). The following code incorporates the average transcript length matrix as an offset for an edgeR analysis.

But I will use the tximport object to get the data to EdgeR, and normalize the data by the length of the transcript.

```{r EdgeR_count_data, echo=TRUE, include=FALSE}
library(edgeR)
#I will use the data from Salmon imported with tximport
counts_salmon<-txidata$counts
normMat <- txidata$length
normMat <- normMat / exp(rowMeans(log(normMat)))
o <- log(calcNormFactors(counts_salmon/normMat)) + log(colSums(counts_salmon/normMat))
EdgeR_s <- DGEList(counts_salmon)
EdgeR_s <- scaleOffset(EdgeR_s, t(t(log(normMat)) + o))
#removing genes with min total counts of 15
keep <- filterByExpr(EdgeR_s)
EdgeR_s <- EdgeR_s[keep,]
#The basic edgeR model fitting and results extraction can be accomplished with the following lines:
EdgeR_s$samples$group<-substr(colnames(txidata$counts),1,nchar(colnames(txidata$counts))-1)
EdgeR_s<- calcNormFactors(EdgeR_s)
EdgeR_s<-estimateDisp(EdgeR_s)
```

## The results from the EdgeR

### Counts of the EdgeRdataset

```{r salmon_edger_dataset}
head(as.data.frame(EdgeR_s$counts))
```

### MDS plot 

```{r MDS_plot_EdgeR}
plotMDS(EdgeR_s)
```

### DE analysis using exact test

I will use the exact test to do the pairwise comparison without any batch effect.

And the number of genes with pvalue < 0.1

```{r EdgeR_salmon_DE}
EdgeR_s$samples$W1<-set_n$W_1
design<-model.matrix(as.formula(~ W1+ group),data =EdgeR_s$samples)
DE_fit<-glmQLFit(EdgeR_s,design=design)
DE_single_factor_edgeR<- glmQLFTest(DE_fit)
sig_DE_EdgeR<-DE_single_factor_edgeR$table[DE_single_factor_edgeR$table$PValue < 0.1,]
dim(sig_DE_EdgeR)
#FDR_edgeR<-p.adjust(DE_single_factor_edgeR$table$PValue, method = "fdr")
#DE_Table<-cbind(DE_single_factor_edgeR$table,FDR_edgeR)
#sig_Table<- DE_Table[DE_Table$FDR_edgeR< 0.1 & DE_Table$logFC > 1 | DE_Table$logFC < -1,]
```

### The toptags table for the sig. DE genes

Number of Genes with log2FoldChange < -1 or > 1, and p.adjusted < 0.1 and the table with the values.

```{r toptags_sig}
Topgenes_sfactor_edgeR<-topTags(DE_single_factor_edgeR, n = nrow(sig_DE_EdgeR))
dim(Topgenes_sfactor_edgeR)
#The FDR is adj. Pvalue  
Topgenes_sfactor_edgeR_0.1_1<- 
Topgenes_sfactor_edgeR[Topgenes_sfactor_edgeR$table$FDR < 0.1   & Topgenes_sfactor_edgeR$table$logFC < -1 | Topgenes_sfactor_edgeR$table$logFC > 1,]
dim(Topgenes_sfactor_edgeR_0.1_1)
head(Topgenes_sfactor_edgeR_0.1_1$table)
Top_Genes_Table<-Topgenes_sfactor_edgeR_0.1_1$table[order(Topgenes_sfactor_edgeR_0.1_1$table$FDR),]
saveRDS(Top_Genes_Table, file = file.path(output_dir,sprintf("%s_vs_%s_EdgeR_sig_Sal_w_outliers.RDS",groups[1], groups[2])))
```



## Get the down regulated genes 

```{r downgenes_edger}
Topgenes_sfactor_edgeR_0.1_1_down<- Topgenes_sfactor_edgeR_0.1_1[Topgenes_sfactor_edgeR_0.1_1$table$logFC < 0, ]
Topgenes_sfactor_edgeR_0.1_1_down<- Topgenes_sfactor_edgeR_0.1_1_down[order(Topgenes_sfactor_edgeR_0.1_1_down$table$logFC), ]
head(Topgenes_sfactor_edgeR_0.1_1_down$table)
dim(Topgenes_sfactor_edgeR_0.1_1_down$table)
```

## Getting the upregulated genes

```{r upgenes_edger}
Topgenes_sfactor_edgeR_0.1_1_up<- Topgenes_sfactor_edgeR_0.1_1[Topgenes_sfactor_edgeR_0.1_1$table$logFC > 0, ]
Topgenes_sfactor_edgeR_0.1_1_up<-Topgenes_sfactor_edgeR_0.1_1_up[order(-Topgenes_sfactor_edgeR_0.1_1_up$table$logFC), ]
head(Topgenes_sfactor_edgeR_0.1_1_up$table)
dim(Topgenes_sfactor_edgeR_0.1_1_up$table)
```

## Creating a volcano plot and a heatmap

```{r volcano_plot_DE_EdgeR_Salmon}
plot(DE_single_factor_edgeR$table$logFC,-log(DE_single_factor_edgeR$table$PValue),main ="Volcano plot", xlab= "Log2FoldChange", ylab = "-log(Pvalue)", pch = 21, col=ifelse(DE_single_factor_edgeR$table$PValue<0.001,"red","black"), xlim= c(-5,5), ylim =c(0,25), abline(v=c(-2,2)))
``` 

heatmap using the top50 variable DE genes (normalized by library size)

```{r normalized_counts_heatmap_edger}
#Using normalized counts
counts_salmon_n <- cpm(EdgeR_s, normalized.lib.sizes = T)
Sig_counts<-counts_salmon_n[row.names(counts_salmon_n) %in% row.names(Topgenes_sfactor_edgeR_0.1_1$table),]
var_genes <- apply(Sig_counts, 1, var)
head(var_genes)
Sig_counts<- cbind(Sig_counts, var_genes)
Sig_counts<-Sig_counts[order(Sig_counts[,7],decreasing =T),]
len<-ifelse(dim(Sig_counts)[1]<50, dim(Sig_counts)[1],50)
heatmap.2(Sig_counts[1:len,1:(ncol(Sig_counts)-1)],  trace="none", 
              main="Most variable genes across samples", scale="row",col = rev(morecols(50)),
              labCol = labels )
```

## Functional analysis of the EdgeR results

Using the DAVIDWEBServices to analize the DE genes and doing the plot2D of terms and evidence: 

```{r EdgeR_DAVID}
if(is.connected(david)== FALSE) {
  connect(david)
}
DAVID_results_EdgeR<- addList(david, row.names(Topgenes_sfactor_edgeR_0.1_1$table), idType = "ENSEMBL_GENE_ID" , listName = sprintf("%s_v_%s_Sig_genes_EdgeR",groups[1],groups[2]) ,listType = "Gene" )
# to see the p% of genes that were recognize on DAVID database
DAVID_results_EdgeR$inDavid
DAVID_results_chart<- getFunctionalAnnotationChart(david)
DAVID_results_chart_EdgeR_BP<-DAVID_results_chart[DAVID_results_chart$Category == "GOTERM_BP_DIRECT" & DAVID_results_chart$PValue < 0.05,]
if(dim(DAVID_results_chart_EdgeR_BP)[1]>0){
plot2D(DAVIDFunctionalAnnotationChart(DAVID_results_chart_EdgeR_BP[1:5,]),
       color=c("FALSE"="black", "TRUE"="green"))
}else{
  print("No significant term found")
}
```

# Comparing the results from DESeq and EdgeR

```{r comparing_David_DESeq_EdgeR}
if(dim(DAVID_results_chart_DESeq_BP)[1]>0 & dim(DAVID_results_chart_EdgeR_BP)[1]>0){
sprintf("DESeq2_%s_%s", groups[1],groups[2])
head(DAVID_results_chart_DESeq_BP[order(DAVID_results_chart_DESeq_BP$PValue),],10)
sprintf("EdgeR_%s_%s", groups[1],groups[2])
head(DAVID_results_chart_EdgeR_BP[order(DAVID_results_chart_EdgeR_BP$PValue),],10)
}else{
  print("Either DESeq or EdgeR functional chart is empty.")
}
# We can see the top 5 GO pathways for biological process, and note how the evidence is true in our data for each of the genes in the pathway( if it is present on our sample or not)
#We can also use the chart to do a godag plot
```

## Significant terms

```{r David_godag}
DAVIDGODag_EdgeR<-DAVIDGODag(DAVIDFunctionalAnnotationChart(DAVID_results_chart_EdgeR_BP), type ="BP",pvalueCutoff=.001)
#we used a cutoff of 0.001 f or the pvalue. And now we can inspect the Dag object
sigCategories(DAVIDGODag_EdgeR, p=0.0001)
summary(DAVIDGODag_EdgeR)
show(DAVIDGODag_EdgeR)
# we can see by the FDR column that only the first 3 pathway are significant
```

## The graph using the EdgeR data

```{r EdgeR_graph}
library(Rgraphviz)
plotGOTermGraph(g=goDag(DAVIDGODag_EdgeR), r= DAVIDGODag_EdgeR, max.nchar= 20, node.shape="ellipse",node.colors=c(sig="red", not="white"))

```


## Comparison between the DESeq2 and EdgeR results

Venndiagram of total genes:

```{r intersect_DESeq_EdgeR}
library(VennDiagram)
# Total DE genes 
I_total<- intersect(rownames(resSig_Salmon), rownames(Topgenes_sfactor_edgeR_0.1_1$table))
length(I_total)
grid.newpage()
draw.pairwise.venn(nrow(resSig_Salmon), nrow(Topgenes_sfactor_edgeR_0.1_1$table), length(I_total), category = c("DESeq2", "EdgeR"), lty = rep("blank", 
    2), fill = c("light blue", "pink"), alpha = rep(0.5, 2), cat.pos = c(-15, 
    0), cat.dist = rep(0.025, 2), title= "DE genes from DESeq and EdgeR")
```

### Comparison between the downregulated genes
```{r down_venndiagram}
I_down<- intersect(rownames(downresSig_Salmon), rownames(Topgenes_sfactor_edgeR_0.1_1_down$table))
length(I_down)
grid.newpage()
draw.pairwise.venn(nrow(downresSig_Salmon), nrow(Topgenes_sfactor_edgeR_0.1_1_down$table), length(I_down), category = c("DESeq2", "EdgeR"), lty = rep("blank", 
    2), fill = c("light blue", "pink"), alpha = rep(0.5, 2), cat.pos = c(-15, 
    0), cat.dist = rep(0.025, 2), title= "Down regulated genes according to DESeq and/or EdgeR")
```

### The upregulated genes 
```{r venn_up}
I_up<- intersect(rownames(upresSig_Salmon), rownames(Topgenes_sfactor_edgeR_0.1_1_up$table))
length(I_up)
grid.newpage()
draw.pairwise.venn(nrow(upresSig_Salmon), nrow(Topgenes_sfactor_edgeR_0.1_1_up$table), length(I_up), category = c("DESeq2", "EdgeR"), lty = rep("blank", 
    2), fill = c("light blue", "pink"), alpha = rep(0.5, 2), cat.pos = c(-15, 
    0), cat.dist = rep(0.025, 2), title= "up DE genes from DESeq and EdgeR")

```

## Get the list of the genes that are in both DESeq2  and edgeR DE genes.

```{r saving_intersect}
head(I_total)
Salmon_intersect<-gene_names[rownames(gene_names) %in% I_total, ]
saveRDS(Salmon_intersect,file = file.path(output_dir,sprintf("%s_vs_%s_Salmon_intersect_w_outliers.RDS",groups[1], groups[2])))
```
###### Session info
```{r session_info}
sessionInfo()
```
